{"version":3,"sources":["node_modules/whatwg-fetch/fetch.js","node_modules/isomorphic-fetch/fetch-npm-browserify.js","node_modules/fast-xml-parser/src/util.js","node_modules/fast-xml-parser/src/n2j.js","node_modules/fast-xml-parser/src/xmlNode.js","node_modules/fast-xml-parser/src/x2j.js","node_modules/fast-xml-parser/src/nimndata.js","node_modules/fast-xml-parser/src/n2j_str.js","node_modules/fast-xml-parser/src/validator.js","node_modules/fast-xml-parser/src/j2x.js","node_modules/fast-xml-parser/src/parser.js","index.js"],"names":["GOODREADS_KEY","cors","goodreads","goodreadsURL","bookURL","fetch","require","fastXmlParser","similarBooks","mainBook","init","node","document","querySelector","addEventListener","event","key","preventDefault","removePreviousResults","progressBar","createElement","className","appendChild","query","value","path","stringifyQuery","then","getText","xmlToJSON","id","jsonData","GoodreadsResponse","search","results","work","best_book","author","name","searchBook","book","title","similar_books","forEach","simBook","link","authors","push","addSimilarBooks","catch","hideProgressBar","xmlData","parse","res","text","showSnackbar","message","snackbar","innerHTML","body","style","bottom","display","element","similarBooksSection","singleBook","deleteElement","parentNode","removeChild","addBookToPage","bookElement","createBook","h1","textAlign","image","undefined","pages","rating","result","slice","window","onload"],"mappings":"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","file":"similar.fe1d4ffa.map","sourceRoot":"..","sourcesContent":["(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status === undefined ? 200 : options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n","\"use strict\";\n\nconst getAllMatches = function(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while (match) {\n        const allmatches = [];\n        const len = match.length;\n        for (let index = 0; index < len; index++) {\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n};\n\nconst doesMatch = function(string, regex) {\n    const match = regex.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\n\nconst doesNotMatch = function(string, regex) {\n    return !doesMatch(string, regex);\n};\n\nexports.isExist = function(v) {\n    return typeof v !== \"undefined\";\n};\n\nexports.isEmptyObject = function(obj) {\n    return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for (let i = 0; i < len; i++) {\n            target[keys[i]] = a[keys[i]];\n        }\n    }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options,defaultOptions,props) {\n    var newOptions = {};\n    if (!options) {\n        return defaultOptions; //if there are not options\n    }\n\n    for (let i = 0; i < props.length; i++) {\n        if ( options[props[i]] !== undefined) {\n            newOptions[props[i]] = options[props[i]];\n        }else{\n            newOptions[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return newOptions;\n};\n\nexports.doesMatch = doesMatch;\nexports.doesNotMatch = doesNotMatch;\nexports.getAllMatches = getAllMatches;\n","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst convertToJson =function(node, options) {\n    const jObj = {};\n\n    if ((!node.child  ||  util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else {\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    util.merge(jObj, node.attrsMap);\n\n    const keys = Object.keys(node.child);\n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (var tag in node.child[tagname]) {\n                jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n    \n    //add value\n    return jObj;\n};\n\nexports.convertToJson = convertToJson;","\"use strict\";\n\nmodule.exports = function(tagname, parent, val) {\n    this.tagname = tagname;\n    this.parent = parent;\n    this.child = {};//child tags\n    this.attrsMap = {};//attributes map\n    this.val = val;//text only\n    this.addChild = function(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    };\n};\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst xmlNode = require(\"./xmlNode\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\nlet regx = \"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))([^>]*)>|((\\\\/)(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))\\\\s*>))([^<]*)\";\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix:    \"@_\",\n    attrNodeName:           false,\n    textNodeName:           \"#text\",\n    ignoreAttributes:       true,\n    ignoreNameSpace:        false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue:         true,\n    parseAttributeValue:    false,\n    arrayMode:              false,\n    trimValues:             true,                                //Trim string values of tag and attributes\n    cdataTagName:           false,\n    cdataPositionChar:      \"\\\\c\",\n    localeRange:            \"\",\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n    //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\"attributeNamePrefix\", \"attrNodeName\", \"textNodeName\", \"ignoreAttributes\", \"ignoreNameSpace\", \"allowBooleanAttributes\", \"parseNodeValue\", \"parseAttributeValue\", \"arrayMode\", \"trimValues\", \"cdataTagName\", \"cdataPositionChar\", \"localeRange\", \"tagValueProcessor\", \"attrValueProcessor\"];\nexports.props = props;\n\nconst getTraversalObj = function(xmlData, options) {\n    options = buildOptions(options,defaultOptions,props);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new xmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    regx = regx.replace(/\\[\\\\w/g, \"[\" + options.localeRange + \"\\\\w\");\n    const tagsRegx = new RegExp(regx, \"g\");\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = util.getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            if (currentNode && tag[14]) {\n                currentNode.val = util.getValue(currentNode.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse) {\n    if (shouldParse && typeof val === \"string\") {\n        if (val.trim() === \"\" || isNaN(val)) {\n            val = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if (val.indexOf(\".\") !== -1) {\n                val = Number.parseFloat(val);\n            } else {\n                val = Number.parseInt(val, 10);\n            }\n        }\n        return val;\n    } else {\n        if (util.isExist(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for (let i = 0; i < len; i++) {\n            const attrName = resolveNameSpace(matches[i][1], options);\n            if (attrName.length) {\n                if (matches[i][4] !== undefined) {\n                    if (options.trimValues) {\n                        matches[i][4] = matches[i][4].trim();\n                    }\n                    matches[i][4] = options.attrValueProcessor(matches[i][4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","\"use strict\";\nconst char = function(a) {\n    return String.fromCharCode(a);\n};\n\nconst chars = {\n    nilChar : char(176),\n    missingChar : char(201),\n    nilPremitive : char(175),\n    missingPremitive : char(200),\n\n    emptyChar : char(178),\n    emptyValue:  char(177),//empty Premitive\n    \n    boundryChar : char(179),\n    \n    objStart: char(198),\n    arrStart: char(204),\n    arrayEnd: char(185),\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.emptyValue,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = function(node, e_schema, options) {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                const arr_len = node.length;\n\n                if (typeof itemSchema === \"string\") {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = getValue(node[arr_i].val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = _e(node[arr_i], itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                const keys = Object.keys(e_schema);\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let i in keys) {\n                    const key = keys[i];\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = function(a/*, type*/) {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = function(str, r) {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = function(ch) {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n}\n\nconst x2j = require(\"./x2j\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n    return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst x2j = require(\"./x2j\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options,0);\n}\n\nconst _cToJsonStr = function(node, options,level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    const keys = Object.keys(node.child);\n    \n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj  += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (var tag in node.child[tagname]) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0,jObj.length-1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" +tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    util.merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (util.isEmptyObject(jObj)) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else {\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName +\"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if(jObj[jObj.length-1] === \",\"){\n        jObj = jObj.substr(0,jObj.length-2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v){\n    if(v === true || v === false || !isNaN(v)){\n        return v;\n    }else{\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false,         //A tag can have attributes without any value\n    localeRange:  \"a-zA-Z\"\n};\n\nconst props = [\"allowBooleanAttributes\", \"localeRange\"];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n    options = util.buildOptions(options,defaultOptions,props);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    if (xmlData[0] === \"\\ufeff\") {  // check for byte order mark (BOM)\n      xmlData = xmlData.substr(1);\n    }\n    const regxAttrName = new RegExp(\"^[_w][\\\\w\\\\-.:]*$\".replace(\"_w\", \"_\" + options.localeRange));\n    const regxTagName = new RegExp(\"^([w]|_)[\\\\w.\\\\-_:]*\".replace(\"([w\", \"([\" + options.localeRange));\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") { //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName, regxTagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid === true) {\n                        tagFound = true;\n                        //continue; //text may presents after self closing tag\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    var start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {//tagname\n            var tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nvar doubleQuote = \"\\\"\";\nvar singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options, regxAttrName) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let i = 0; i < matches.length; i++) {\n        //console.log(matches[i]);\n\n        if (matches[i][1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + matches[i][2] + \" has no space in starting.\"}};\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + matches[i][2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = matches[i][2];\n        if (!validateAttrName(attrName, regxAttrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\n// const validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName, regxAttrName) {\n    // const validAttrRegxp = new RegExp(regxAttrName);\n    return util.doesMatch(attrName, regxAttrName);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\n//  startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname, regxTagName) {\n    /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !util.doesNotMatch(tagname, regxTagName);\n}\n","\"use strict\";\n//parse Empty Node as self closing node\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n};\n\nconst props = [\n    \"attributeNamePrefix\",\n    \"attrNodeName\",\n    \"textNodeName\",\n    \"ignoreAttributes\",\n    \"cdataTagName\",\n    \"cdataPositionChar\",\n    \"format\",\n    \"indentBy\",\n    \"supressEmptyNode\",\n    \"tagValueProcessor\",\n    \"attrValueProcessor\"\n]\n\nfunction Parser(options) {\n    this.options = buildOptions(options,defaultOptions,props);\n    if (this.options.ignoreAttributes || this.options.attrNodeName) {\n        this.isAttribute = function(/*a*/) { return false;};\n    } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n    }\n    if (this.options.cdataTagName) {\n        this.isCDATA = isCDATA;\n    } else {\n        this.isCDATA = function(/*a*/) { return false;};\n    }\n    this.replaceCDATAstr = replaceCDATAstr;\n    this.replaceCDATAarr = replaceCDATAarr;\n\n    if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n    } else {\n        this.indentate = function() { return \"\";};\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n    }\n\n    if (this.options.supressEmptyNode) {\n        this.buildTextNode = buildEmptyTextNode;\n        this.buildObjNode = buildEmptyObjNode;\n    } else {\n        this.buildTextNode = buildTextValNode;\n        this.buildObjNode = buildObjectNode;\n    }\n\n    this.buildTextValNode = buildTextValNode;\n    this.buildObjectNode = buildObjectNode;\n\n}\n\nParser.prototype.parse = function(jObj) {\n    return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n    let attrStr = \"\";\n    let val = \"\";\n    const keys = Object.keys(jObj);\n    const len = keys.length;\n    for (let i = 0; i < len; i++) {\n        const key = keys[i];\n        if (typeof jObj[key] === \"undefined\") {\n            // supress undefined node\n        }else if (jObj[key] === null) {\n            val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n        }else if (typeof jObj[key] !== \"object\") {//premitive type\n            const attr = this.isAttribute(key);\n            if (attr) {\n                attrStr += \" \" + attr + \"=\\\"\" +  this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n            } else if (this.isCDATA(key)) {\n                if (jObj[this.options.textNodeName]) {\n                    val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                    val += this.replaceCDATAstr(\"\", jObj[key]);\n                }\n            } else {//tag value\n                if (key === this.options.textNodeName) {\n                    if (jObj[this.options.cdataTagName]) {\n                        //value will added while processing cdata\n                    } else {\n                        val +=  this.options.tagValueProcessor(\"\" + jObj[key]);\n                    }\n                } else {\n                    val += this.buildTextNode(jObj[key], key, \"\", level);\n                }\n            }\n        } else if (Array.isArray(jObj[key])) {//repeated nodes\n            if (this.isCDATA(key)) {\n                if (jObj[this.options.textNodeName]) {\n                    val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                    val += this.replaceCDATAarr(\"\", jObj[key]);\n                }\n            } else {//nested nodes\n                const arrLen = jObj[key].length;\n                for (let j = 0; j < arrLen; j++) {\n                    const item = jObj[key][j];\n                    if (typeof item === \"undefined\") {\n                        // supress undefined node\n                    }else if(item === null){\n                        val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n                    }else if (typeof item === \"object\") {\n                        const result = this.j2x(item, level + 1);\n                        val += this.buildObjNode(result.val, key, result.attrStr, level);\n                    } else {\n                        val += this.buildTextNode(item, key, \"\", level);\n                    }\n                }\n            }\n        } else {//nested node\n            if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                const Ks = Object.keys(jObj[key]);\n                const L = Ks.length;\n                for (let j = 0; j < L; j++) {\n                    attrStr += \" \" + Ks[j] + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][Ks[j]]) + \"\\\"\";\n                }\n            } else {\n                const result = this.j2x(jObj[key], level + 1);\n                val += this.buildObjNode(result.val, key, result.attrStr, level);\n            }\n        }\n    }\n    return {attrStr: attrStr, val: val};\n};\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]>\";\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]>\");\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]>\";\n    } else {\n        for (let v in cdata) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n    return this.indentate(level)\n           + \"<\" + key + attrStr\n           + this.tagEndChar\n           + val\n           //+ this.newLine\n           + this.indentate(level)\n           + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n","\"use strict\";\n\nconst nodeToJson = require(\"./n2j\");\nconst xmlToNodeobj = require(\"./x2j\");\nconst x2j = require(\"./x2j\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nexports.parse = function(xmlData, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n    return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);\n};\nexports.convertTonimn = require(\"../src/nimndata\").convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require(\"./n2j_str\").convertToJsonString;\nexports.validate = require(\"./validator\").validate;\nexports.j2xParser = require(\"./j2x\");\nexports.parseToNimn = function (xmlData,schema,options){\n    return exports.convertTonimn(exports.getTraversalObj(xmlData,options), schema, options);\n};\n","const GOODREADS_KEY = process.env.GOODREADS_KEY;\nconst cors = \"https://cors-anywhere.herokuapp.com/\";\nconst goodreads = \"https://www.goodreads.com/\";\nconst goodreadsURL = cors + goodreads + \"search/index.xml?\";\nconst bookURL = cors + goodreads + \"book/show.xml?\";\n\nconst fetch = require('isomorphic-fetch');\nconst fastXmlParser = require('fast-xml-parser');\n\nlet similarBooks = [];\nlet mainBook = {};\n\nfunction init() {\n\n    const node = document.querySelector(\".searchInput\");\n\n    node.addEventListener(\"keydown\", function (event) {\n        if (event.key === \"Enter\") {\n            event.preventDefault();\n\n            removePreviousResults();\n\n            const progressBar = document.createElement('progress');\n            progressBar.className = \"progress\";\n            container.appendChild(progressBar);\n\n            const query = {\n                q: node.value,\n                field: \"title\",\n                key: GOODREADS_KEY\n            }\n\n            const path = goodreadsURL + stringifyQuery(query);\n\n            fetch(path)\n                .then(getText)\n                .then(xmlToJSON)\n                .then(jsonData => {\n                    const id = jsonData.GoodreadsResponse.search.results.work[0].best_book.id;\n                    const author = jsonData.GoodreadsResponse.search.results.work[0].best_book.author.name;\n                    mainBook[\"id\"] = id;\n                    mainBook[\"author\"] = author;\n                    return id;\n                })\n                .then(id => {\n\n                    const query = {\n                        format: 'xml',\n                        id: id,\n                        key: GOODREADS_KEY,\n                    }\n                    const path = bookURL + stringifyQuery(query);\n                    return fetch(path);\n                })\n                .then(getText)\n                .then(xmlToJSON)\n                .then(jsonData => {\n                    const searchBook = jsonData.GoodreadsResponse.book;\n\n                    mainBook[\"name\"] = searchBook.title;\n                    mainBook[\"image\"] = searchBook[\"image_url\"]\n                    mainBook[\"rating\"] = searchBook[\"average_rating\"]\n                    mainBook[\"pages\"] = searchBook[\"num_pages\"]\n\n                    addBookToPage(mainBook);\n\n                    const simBooks = jsonData.GoodreadsResponse.book.similar_books.book;\n\n                    simBooks.forEach(book => {\n                        const simBook = {\n                            name: book.title,\n                            id: book.id,\n                            link: book.link,\n                            image: book[\"image_url\"],\n                            author: book.authors.author.name,\n                            pages: book[\"num_pages\"],\n                            rating: book[\"average_rating\"]\n                        };\n\n                        similarBooks.push(simBook);\n                    });\n\n                    addSimilarBooks();\n                })\n                .catch(err => {\n                    hideProgressBar();\n                    showSnackbar(\"Error: Couldn't find any books!\");\n                });\n        }\n    });\n}\n\nfunction xmlToJSON(xmlData) {\n    return fastXmlParser.parse(xmlData);\n}\n\nfunction getText(res) {\n    return res.text();\n}\n\nfunction showSnackbar(message) {\n    const snackbar = document.createElement('div');\n    snackbar.className = \"snackbar\";\n    snackbar.innerHTML = `<p>${message}</p>`;\n    document.body.appendChild(snackbar);\n    snackbar.style.bottom = \"1vh\";\n    setTimeout(() => {\n        snackbar.style.display = \"none\";\n    }, 2000);\n}\n\nfunction hideProgressBar() {\n    const element = document.querySelector('.progress');\n    deleteElement(element);\n}\n\n\nfunction removePreviousResults() {\n    mainBooks = {};\n    similarBooks = [];\n    const similarBooksSection = document.querySelector('.similarBooksSection');\n\n    const singleBook = document.querySelector('.book');\n\n    if (similarBooksSection) {\n        deleteElement(similarBooksSection);\n    }\n\n    if (singleBook) {\n        deleteElement(singleBook);\n    }\n}\n\nfunction deleteElement(element) {\n    element.parentNode.removeChild(element);\n}\n\n\nfunction addBookToPage(book) {\n    const bookElement = createBook(book);\n    hideProgressBar();\n    container.appendChild(bookElement);\n    return;\n}\n\nfunction addSimilarBooks() {\n    const similarBooksSection = document.createElement('div');\n    similarBooksSection.className = \"similarBooksSection\";\n\n    const h1 = document.createElement('h1');\n    h1.innerHTML = \"Similar Books\";\n    h1.style.textAlign = \"center\";\n    similarBooksSection.appendChild(h1);\n\n    similarBooks.forEach(book => {\n        similarBooksSection.appendChild(createBook(book));\n    });\n\n    container.appendChild(similarBooksSection);\n}\n\nfunction createBook(book) {\n\n    const bookElement = document.createElement('div');\n    bookElement.className = \"book\";\n\n    bookElement.innerHTML = `\n    <img src=${book.image} alt=\"book_cover\" widht=\"50\" height=\"75\" class=\"bookImage\"/>\n    <div class=\"bookInfo\">\n    <p class=\"title\">\n        <a href=${book.link === undefined ? \"\" : book.link}><b>${book.name}</b></a> &mdash;\n        <span class=\"author\">\n            <em>${book.author}</em>\n        </span>\n    </p>\n    <p class=\"pages\">Pages:\n        <span class=\"extraContent\">${book.pages}</span>\n    </p>\n    <p class=\"rating\">Rating:\n        <span class=\"extraContent\">${book.rating}</span>\n    </p>\n    </div>`;\n\n    return bookElement;\n}\n\n/**\n * \n * @param {string} query \n */\nfunction stringifyQuery(query) {\n    let result = \"\";\n    for (let key in query) {\n        result += key + \"=\" + query[key] + \"&\";\n    }\n    return result.slice(0, -1);\n}\n\nwindow.onload = init;"]}